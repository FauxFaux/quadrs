fn run_of(data: &[bool], scale: usize, val: bool) -> usize {
    let mut bad = 0;
    for i in 0..data.len() {
        if data[i] != val {
            bad += 1;
        } else {
            bad = 0;
        }

        if bad > scale {
            return i + 1 - bad;
        }
    }

    data.len()
}

#[cfg(test)]
mod tests {

    #[test]
    fn run() {
        use super::run_of;
        assert_eq!(4, run_of(&parse("0000"), 2, false), "runs a whole buffer");
        assert_eq!(
            8,
            run_of(&parse("00001000111"), 2, false),
            "doesn't trip over a single bit flip at 2"
        );
    }

    #[test]
    fn de_run() {
        let inp = parse(
            r#"11
                 010000000111110000011111000001111100001111100000111110000011111000001111100001
                 111100000111110000011111000001111100000111100000111110000011111000001111100000
                 111110000111110000011111000001111100000111110000111110000011111000001111100000
                 111110000111110000011111000001111100000111110000011110000011111000001111100000
                 11111000001111111110000000000000000000000001111111111000000000111110000011111
                 000000000011111111110000000000000000000000001111111111111111111111111111111111
                 000001111100000000001111100001111111111000000000000000111111111111111000011111
                 000001111100000000000000011111000000000000000000000000111110000000000000000000
                 00000111111110101"#,
        );
    }

    fn parse(s: &str) -> Vec<bool> {
        s.chars()
            .flat_map(|x| match x {
                '0' => Some(false),
                '1' => Some(true),
                x if x.is_whitespace() => None,
                _ => panic!("invalid"),
            })
            .collect()
    }
}
